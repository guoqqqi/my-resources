(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('axios'), require('unist-util-select')) :
	typeof define === 'function' && define.amd ? define(['exports', 'axios', 'unist-util-select'], factory) :
	(global = global || self, factory(global['@agentofuser/remark-oembed'] = {}, global.axios, global.unistUtilSelect));
}(this, function (exports, axios, unistUtilSelect) { 'use strict';

	axios = axios && axios.hasOwnProperty('default') ? axios['default'] : axios;

	// A type of promise-like that resolves synchronously and supports only one observer

	const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

	const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

	// Asynchronously call a function and send errors to recovery continuation
	function _catch(body, recover) {
		try {
			var result = body();
		} catch(e) {
			return recover(e);
		}
		if (result && result.then) {
			return result.then(void 0, recover);
		}
		return result;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	var fetchOembed = function fetchOembed(endpoint) {
	  try {
	    return Promise.resolve(axios.get(endpoint.url, {
	      params: _extends({
	        format: 'json'
	      }, endpoint.params)
	    })).then(function (response) {
	      return response.data;
	    });
	  } catch (e) {
	    return Promise.reject(e);
	  }
	};

	var OEMBED_PROVIDERS_URL = 'https://oembed.com/providers.json';

	var fetchOembededProviders = function fetchOembededProviders() {
	  try {
	    return Promise.resolve(axios.get(OEMBED_PROVIDERS_URL)).then(function (response) {
	      return response.data;
	    });
	  } catch (e) {
	    return Promise.reject(e);
	  }
	};

	var getProviderEndpointForLinkUrl = function getProviderEndpointForLinkUrl(linkUrl, providers) {
	  var transformedEndpoint = {
	    url: null,
	    params: null
	  };

	  for (var _iterator = providers || [], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var provider = _ref;

	    for (var _iterator2 = provider.endpoints || [], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	      var _ref2;

	      if (_isArray2) {
	        if (_i2 >= _iterator2.length) break;
	        _ref2 = _iterator2[_i2++];
	      } else {
	        _i2 = _iterator2.next();
	        if (_i2.done) break;
	        _ref2 = _i2.value;
	      }

	      var endpoint = _ref2;

	      for (var _iterator3 = endpoint.schemes || [], _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	        var _ref3;

	        if (_isArray3) {
	          if (_i3 >= _iterator3.length) break;
	          _ref3 = _iterator3[_i3++];
	        } else {
	          _i3 = _iterator3.next();
	          if (_i3.done) break;
	          _ref3 = _i3.value;
	        }

	        var schema = _ref3;
	        schema = schema.replace('*', '.*');
	        var regExp = new RegExp(schema);

	        if (regExp.test(linkUrl)) {
	          transformedEndpoint.url = endpoint.url;
	          transformedEndpoint.params = _extends({
	            url: linkUrl
	          }, provider.params);
	        }
	      }
	    }
	  }

	  return transformedEndpoint;
	};

	var selectPossibleOembedLinkNodes = function selectPossibleOembedLinkNodes(markdownAST, usePrefix) {
	  if (usePrefix === void 0) {
	    usePrefix = false;
	  }

	  var res = [];

	  if (usePrefix === true) {
	    var nodes = unistUtilSelect.selectAll(markdownAST, 'inlineCode');
	    nodes.forEach(function (node) {
	      if (node.value.startsWith('oembed:')) {
	        var mutatedNode = node;
	        mutatedNode.url = mutatedNode.value.substring(7).trim();
	        res.push(mutatedNode);
	      }
	    });
	  } else {
	    res = unistUtilSelect.selectAll('paragraph link:only-child', markdownAST);
	  }

	  return res || [];
	};

	var transformLinkNodeToOembedNode = function transformLinkNodeToOembedNode(node, oembedResult) {
	  if (oembedResult.html) {
	    node.type = 'html';
	    node.value = oembedResult.html;
	    delete node.children;
	  } else if (oembedResult.type === 'photo') {
	    node.type = 'html';
	    node.value = "\n      <img src=\"" + oembedResult.url + "\"\n        class=\"gatsby-remark-oembed-photo\"\n        width=\"" + oembedResult.width + "\"\n        height=\"" + oembedResult.width + "\"\n        title=\"" + oembedResult.title + "\"/>\n    ";
	    delete node.children;
	  }

	  return node;
	};

	var transformer = function transformer(tree, _file) {
	  try {
	    return Promise.resolve(fetchOembededProviders()).then(function (providers) {
	      var usePrefix = false;
	      var nodes = selectPossibleOembedLinkNodes(tree, usePrefix);
	      return Promise.resolve(Promise.all(nodes.map(function (node) {
	        return processNode(node, providers);
	      }))).then(function () {
	        return tree;
	      });
	    });
	  } catch (e) {
	    return Promise.reject(e);
	  }
	};

	var processNode = function processNode(node, providers) {
	  if (providers === void 0) {
	    providers = [];
	  }

	  try {
	    var _exit2 = false;
	    var mutatedNode = node;

	    var _temp3 = _catch(function () {
	      var endpoint = getProviderEndpointForLinkUrl(node.url, providers);

	      var _temp = function () {
	        if (endpoint.url) {
	          return Promise.resolve(fetchOembed(endpoint)).then(function (oembedResponse) {
	            mutatedNode = transformLinkNodeToOembedNode(node, oembedResponse);
	          });
	        }
	      }();

	      if (_temp && _temp.then) return _temp.then(function () {});
	    }, function (error) {
	      error.url = node.url;
	      throw error;
	    });

	    return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function (_result) {
	      return _exit2 ? _result : mutatedNode;
	    }) : _exit2 ? _temp3 : mutatedNode);
	  } catch (e) {
	    return Promise.reject(e);
	  }
	};

	function attacher() {
	  return transformer;
	}

	exports.default = attacher;

}));
//# sourceMappingURL=agentofuserremark-oembed.umd.development.js.map
